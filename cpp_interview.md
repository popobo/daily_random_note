# 表达式，左值，右值和引用
- 表达式时可求值的，对表达式求值可得到一个结果，结果有两个属性
    - 类型（int, string或自定义类型）
    - 值类别
        - 五个类别分别基于表示的两个特征
            - 具名（identity）：可以确定表达式是否与另一表达式指代同一实体，可以在等号左边，能够取地址
            - 可被移动：移动构造函数、移动复制运算符或实现了移动语义的其他函数重载能否绑定于这个表表达式
        - 五种类型
            - 左值（lvalue，left value：具名且不可被移动
                - 特征：
                    - 可通过取地址运算符获取其地址（可以取地址）
                    - 可修改的左值可用作内建赋值和内建符合赋值运算符的左操作数（可以放在等号左边）
                    - 可以用来初始化左值引用
                - 例子
                    - 变量名、函数名以及数据成员名
                    - 返回左值引用的函数调用
                    - 由赋值运算符或复合赋值运算符连接的表达式，如(a=b, a-=b等)
                    - 解引用表达式 *ptr
                    - 下标运算符的结果([])
                    - 
                        ```c++
                            int a = 1; // a是左值
                            T& f();
                            f();//左值
                            ++a;//左值
                            --a;//左值
                            int b = a;//a和b都是左值
                            struct S* ptr = &obj; // ptr为左值
                            arr[1] = 2; // 左值
                            int *p = &a; // p为左值
                            *p = 10; // *p为左值
                            class MyClass{};
                            MyClass c; // c为左值
                        ```
            - 将亡值（xvalue，expiring value)：具名且可被移动
                - 顾名思义即将消亡的值，是C++11新增的跟右值引用相关的表达式，通常是将要被移动的对象（移为他用）
                - 例子
                    - 返回右值引用T&&的函数的返回值
                    - std::move的返回值
                    - 转换为T&&的类型转换函数的返回值
                - 只能用两种方式获得
                    - 返回右值引用的函数的调用表达式,如 static_cast<T&&>(t); 该表达式得到一个 xvalue
                    - 转换为右值引用的转换函数的调用表达式，如：std::move(t)
                    - 
                        ```c++
                        std::string fun() {
                        std::string str;
                        // ...
                        return str;
                        }

                        std::string s = fun();
                        ```
                        - C++11前，s = fun();会调用拷贝构造函数
                        - C++11后，s = fun();会被优化为move操作，
                        str会被进行隐式右值转换，等价于static_cast<std::string&&>(str)，
                        即触发s相对应的移动构造，或移动赋值运算符，
                        没有移动构造或移动赋值运算符则调用拷贝构造或拷贝赋值运算符，都没有则报错
                        - 然后str都会被销毁，所以是将亡值
                        - 实际上编译器可能会帮你优化成只调用一次构造函数，
                        添加编译选项"-fno-elide-contruction"可以取消这个优化
            - 纯右值（pvalue，pure value）：不具名且可被移动
                - 特征： 只能在等号右边，不能取地址，不具名
                - 例子
                    - 字面值(字符串字面值除外)，例如1，'a', true等
                    - 返回值为非引用的函数调用或操作符重载，
                    例如：str.substr(1, 2), str1 + str2, or it++
                    - 后置自增和自减表达式(a++, a--)
                    - 算术表达式
                    - 逻辑表达式
                    - 比较表达式
                    - 取地址表达式
                    - lambda表达式
                    - 
                        ```c++
                        // 字面值
                        nullptr;
                        true;
                        1;
                        // 返回值为非引用的函数调用
                        int func();
                        func();

                        //后置自增/自减表达式
                        a++;
                        a--;
                        //逻辑表达式
                        a && b;
                        //比较表达式
                        a > b;
                        ```
            - 混合类别
                - 泛左值（glvalue，generalized lvalue）：具名，lvalue和xvalue都属于glvalue
                - 右值（rvalue，right value）：可被移动的表达式，prvalue和xvalue都属于rvalue
    - 引用
        - 特点：
            - 变量别名
            - 声明时必须初始化
            - 通过引用可以修改变量
        - C++11中有三种引用
            - 左值引用
            - 常量左值引用（不希望被修改）
                ```c++
                std::string str = "abc";
                std::string &s = str;
                const int &a = 10;
                int &b = 10; //错，右值不能绑定左值引用
                ```
            - 右值引用
                - 右值引用可以延长右值（主要是将亡值）的生命周期，右值引用的作用就是为了绑定右值
                - 
                    ```c++
                    int a = 1;
                    int &rb = a; // b为左值引用
                    int &&rrb = a; // 错误，a是左值，右值引用不能绑定左值
                    int &&rbb1 = 10; // 正确，10为右值
                    int &rb1 = i * 2; // 错误，i * 2 为右值
                    int &&rb2 = i * 2; // 正确
                    const int &c = 1; // 正确
                    const int &c1 = i * 2; // 正确
                    ```
                - 作用
                    - 实现移动语义
                        - 对象赋值时，避免资源的重新分配
                        - 移动构造函数以及移动赋值函数
                        - 在stl中有着广泛的应用
                        - std::unique_ptr
                        - std::function
                    - 实现完美转发
                        - 函数模板可以将自己的参数完美地转发给内部调用的其他函数
                        - 完美是指不仅能准确转发参数的值，还能保证被转发的参数的左右值属性不变
                        - 
                            ```c++
                                template<typename T>
                                void revoke(T &&t){
                                    // t是左值
                                    func(std::forward<T>(t));
                                }
                                revoke(10); //右值或右值引用，int &&&& -> int &&
                                int i = 10;
                                revoke(i); // 传入左值，int && -> int & ?
                                int &j = i;
                                revoke(j); // 传入左值引用，int &&& -> int &
                            ```
                        - 借用万能引用（T &&t)，通过引用的方式接收左右属性的值
                        - 引用折叠规则
                            - 参数为左值或左值引用，T&&将转化为int&
                            - 参数为右值或右值引用，T&&将转化为int&&
                            - 引用一般不能指向引用，除了这种情况 
                        - std::forward<T>(v)
                            - T为左值引用，v将转化为T类型的左值
                            - T为右值引用，v将转化为T类型的右值
                            - 去除引用
                
            

