# PA1 开天辟地的篇章：最简单的计算机
- 在开始愉快的PA之旅之前
    - NEMU是什么？
    - 选择你的角色
    - 还等什么呢？
- 开天辟地的篇章
    - 最简单的计算机
        - 计算机可以没有寄存器吗？
        如果没有寄存器，计算机仍然可以工作，但是它的执行效率会受到很大的影响，因为没有寄存器的计算机必须从主存储器中读取和存储数据，这会导致非常慢的执行速度。
        在没有寄存器的情况下，计算机的编程模型也会发生很大变化。通常，程序员需要在每个指令中明确地指定操作数的内存地址，而不是将它们存储在寄存器中。这将导致更长的指令序列和更慢的执行速度。
        此外，缺乏寄存器可能会使编写高级编程语言变得更加困难。现代编译器和解释器通常使用寄存器来管理变量和临时数据，从而在运行时提高程序的执行效率。没有寄存器可能需要使用更复杂的技术来实现相同的优化，这会使编译器的实现更加复杂。
        - 尝试理解计算机如何计算
        - 计算机是个状态机
    - 重新认识程序：程序是个状态机
        - 从状态机视角理解程序运行
        - 程序的状态机视角有什么好处？
        - "程序在计算机上运行"的微观视角：程序是个状态机
- RTFSC
    - 框架代码初探
        - 需要多费口舌吗？
        - 对vim的使用感到困难？
    - 准备第一个客户程序
        - 为什么全部都是函数？
        - 参数的处理过程
        - BIOS和计算机启动
        - 初探操作系统启动
        - 物理内存的起始地址
        - 实现x86的寄存器结构体
            - 什么是匿名union?
            - reg_test()是如何测试你的实现的?
    - 运行第一个用户程序
        - 究竟要执行多久?
        - 潜在的威胁
        - 谁来指示程序的结束？
        - 有始有终
        - 理解框架代码
        - RTFSC != 盯着代码看
        - 阅读Makefile
    - 就这么简单
- 基础设施
    - 基础设施-提高项目开发的效率
        - 真实故事
        - 总有一天会找上来的bug
    - 解析命令
        - 如何测试字符串处理函数？
    - 单步执行
    - 打印寄存器
    - 扫描内存
        - 实现单步执行，打印寄存器，扫描内存
        - 我怕代码写错了啊，怎么办？
    - 表达式求值
        - 数学表达式求值
            - 词法分析
                - 实现算术表达式的词法分析
                - 调试公理
                - 如何调试
                - 为什么printf()的输出要换行?
                printf()函数在执行输出操作时会使用缓冲区（buffer），将需要输出的数据先暂存在缓冲区中，待缓冲区满或遇到换行符'\n'时才将缓冲区中的数据一次性输出到目标设备上，比如屏幕或文件等。
                这种使用缓冲区的方式可以提高输出效率，减少频繁的I/O操作对系统性能的影响。但也会带来一些问题，比如缓冲区未满时程序异常退出导致缓冲区中的数据没有被输出；或者在不及时刷新缓冲区的情况下，需要等到缓冲区满或遇到换行符才能看到输出结果，可能会给调试程序带来困难等等。
                因此，在需要及时看到输出结果或需要确保缓冲区中的数据被及时输出的情况下，可以使用fflush()函数来刷新缓冲区。例如，调用printf()输出一条消息后，紧接着调用fflush(stdout)来确保消息被及时输出。
                - 系统设计的黄金法则-KISS法则
            - 递归求值
                - 实现算数表达式的递归求值
                - 实现带有负数的算数表达式的求值（选做）
                - 从表达式求值窥探编译器
                - 如何测试你的代码
        - 如何测试你的代码
            - 表达式生成器如何获得C程序的打印结果
            - 为什么需要使用无符号类型
            - 除0的确切行为
            - 过滤除0行为的表达式
            - 实现表达式生成器
    - 监视点
        - 扩展表达式求值的功能
            - 扩展表达式求值的功能
            - riscv64中的表达式求值
            - 测试的局限性
        - 实现监视点
            - 实现监视点池的管理
            - 温故而知新
            - 实现监视点
    - 调试工具与原理
        - 你会如何测试你的监视点的实现
        - 强大的GDB
    - 断点
        - 如何提高断点的效率
        - 一点也不能长
        - 随心所欲的断点
        - NEMU的前世今生
- 如何阅读手册
    - 学会使用目录
        - 尝试通过目录定位关注的问题
    - 逐步细化搜索范围

# PA2-简单复杂的机器：冯诺依曼计算机系统
- 不停计算的机器
    - 不停计算的机器
        - 取指(instruction fetch, IF)
        - 译码(instruction decode, ID)
        - 执行(execute, EX)
        - 更新PC
    - YEMU: 一个简单的CPU模拟器
        - 理解YEMU如何执行程序
- RTFSC(2)
    - RTFM
        - i386手册勘误
        - RISC-与CISC平行的另一个世界
        - RISC-V-一款设计精巧的指令集
    - RTFSC(2)
        - 取指(instruction fetch, IF)
        - 译码(instruction decode, ID)
            - 操作数宽度的处理
            - x86的变长指令
            - 立即数背后的故事
            - 立即数背后的故事(2)
            对于MIPS32和RISC-V32这样的32位指令集架构，无法像x86那样直接编码32位常数到一条指令中。这是因为指令长度限制了常数的大小，而且指令中的大部分位用于指定操作码和寄存器操作数。
            为了解决这个问题，MIPS32和RISC-V32使用了两种主要的方法：
            立即数寻址：这种方法允许将一个小的常数（通常为16位或20位）直接编码到指令中，然后在执行时将其扩展为32位。例如，在MIPS32指令集中，可以使用ADDI指令将16位的立即数添加到寄存器中。同样，在RISC-V32指令集中，可以使用ADDI指令将12位的立即数添加到寄存器中。
            加载立即数：另一种方法是将常数存储在内存中，并使用加载指令将其加载到寄存器中。这种方法允许加载更大的常数（通常为32位），但需要额外的指令和存储器访问。例如，在MIPS32指令集中，可以使用LUI指令将16位的立即数加载到寄存器的高位，然后使用ORI指令将另一个16位的立即数加载到寄存器的低位，从而将32位的常数加载到寄存器中。同样，在RISC-V32指令集中，可以使用LUI和ADDI指令将32位的立即数加载到寄存器中。
            总的来说，MIPS32和RISC-V32可以使用立即数寻址和加载立即数这两种方法，将常数加载到寄存器中，以执行操作。这两种方法都有其优点和缺点，需要根据具体情况进行选择。
        - 执行(execute, EX)
        - 更新PC
            - 静态指令和动态指令
            - 驾驭项目, 而不是被项目驾驭
            - 拦截客户程序访存越界的非法行为
    - 结构化程序设计
        - Copy-Paste - 一种糟糕的编程习惯
        - 指令执行的共性部分
        - 用RTL表示指令行为
            - 64位ISA特有的RTL基本指令
            - RTL指令和二进制翻译
            - 神秘的host内存访问 (建议二周目思考)
            - 小型调用约定
            - 计算机系统中的约定与未定义行为
            - UB, 编译优化和datalab
            - RTL寄存器中值的生存期
        - 实现新指令
            - 感觉RTL临时寄存器不够用了?
            - 偏心的框架代码
            - RTFSC理解指令执行的过程
        - 运行第一个C程序
            - 准备交叉编译环境
            - 为什么执行了未实现指令会出现上述报错信息
            - 我选择x86, 但出错信息中显示的字节序列有所不同
            - 交叉编译工具链
            - 去除endbr32指令
            - 再提供一些x86的提示吧
            - 运行第一个客户程序
- 程序，运行时环境与AM
    - 运行时环境
    为了运行最简单的程序, 我们需要提供什么呢? 
    其实答案已经在PA1中了: 只要把程序放在正确的内存位置, 然后让PC指向第一条指令, 计算机就会自动执行这个程序, 永不停止.

    - 将运行时环境封装成库函数
    运行时环境的一种普遍的存在方式: 库. 
    通过库, 运行程序所需要的公共要素被抽象成API, 不同的架构只需要实现这些API
        - 这又能怎么样呢
    - AM-裸机(bare-metal)运行时环境
        - AM的诞生和Project-N的故事
        - 穿越时空的羁绊
        - 为什么要有AM？
            解耦ISA与Nanos-lite
    - RTFSC
        - 阅读Makefile
    - 运行更多的程序
        - 实现更多的指令
        - 不要以为只需要在TODO处写代码
        - 调试的利器-日志
        - x86指令相关的注意事项
        - mips32的分支延迟槽
        - mips32-NEMU的分支延迟槽
        - 指令名对照
    - 实现常用的库函数
        - 实现字符串处理函数
        - 免责声明
        - 实现sprintf
        - stdarg是如何实现的?
    - 重新认识计算机：计算机是个抽象层
        - "程序在计算机上运行"的宏观视角: 计算机是个抽象层
        - PA究竟在干什么
- 基础设施
    - AM作为基础设施
        - 如何生成native的可执行文件
        - 奇怪的错误码
        - 这是如何实现的？
        - 先实现memcpy()
        - 编写可一直的程序
    - 测试你的klib
        - 编写更多的测试（1）
        - 这些库函数这么简单，我可以不测试吗？
        - 编写更多的测试（2）
        - 编写更多的测试（3）
    - Differential Testing
        - 基础设置-龙芯杯获胜的秘诀
        - 实现DiffTest
        - 需要校准的指令
        - KVM: 一个比QEMU更高效的REF
        - 使用QEMU作为REF时, 不要同时运行两份NEMU
        - 匪夷所思的QEMU行为 (有点难度)
    - 一键回归测试
        - NEMU的本质
        - 捕捉死循环（有点难度）
            - 状态机视角，状态空间有一个闭环
- 输入输出
    - 设备与CPU
    访问设备 = 读出数据 + 写入数据 + 控制状态.
    - 端口I/O
        - 有没有一种熟悉的感觉
    - 内存映射I/O
        理解volatile关键字
    -  状态机视角下的输入输出
    - NEMU中的输入输出
        - 映射和I/O方式
    - 设备
    - 将输入输出抽象成IOE
    - 串口
        - 运行Hello World
        - 设备和DiffTest
        - 理解mainargs
        - 实现print
    - 时钟
        - 实现IOE
        - 不要再native连接到klib时运行IOE相关的测试
        - RTFSC尽可能了解一切细节
        - 看看NEMU跑多快
        - 如何调试复杂程序
        - NEMU和语言解释器
        - 先完成，后完美-抑制住优化代码的冲动
        - 运行红白机模拟器
    - 键盘
        - 神秘的MAP宏
        - 实现IOE（2）
        - 如何检测多个键同时被按下？
        - 运行红白机模拟器（2）
    - VGA
        - 神奇的调色板
        - 实现IOE（3）
        - 实现IOE（4）
        - 运行红白机模拟器（3）
    - 声卡
        - 实现声卡
        - 一些提示
        - 注意音量，保护耳朵
        - 音频播放的原理
        - 播放自己的音乐
        - 运行红白机模拟器
    - 冯诺依曼计算机系统
        - 展示你的计算机系统
        - 游戏是如何运行的
        - 体会到AM的好处了吧？
        - RTFSC指南
        - LiteNES如何工作的
        - 优化LiteNES