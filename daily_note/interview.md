## 总结一下完成每个项目收获了什么
- 基于Qt, FFmpeg的视频播放器
    - 1. 通过这个项目实践了多种设计模式
        - 设计模式原则
            - 依赖倒置原则：依赖指的是二进制依赖，编译上的依赖；
            高层模块不应依赖底层模块，二者都应依赖抽象；
            抽象不应依赖于实现细节，实现细节应该依赖抽象；
            即稳定不应依赖变化，变化应该依赖抽象；
            - 开放封闭原则：对扩展开放，对更改封闭，
            类模块应该是可扩展的，但是不可修改；
            - 单一职责原则：一个类应该仅有一个引起它变化的原因，变化的方向隐含着类的责任
            - 接口隔离原则：不应该强迫客户程序依赖它们不用的方法，接口应该小而完备
            - 优先使用组合而非继承：继承在某种程序破坏了封装性（子类可以访问到父类的方法，重载父类的方法等），子类父类耦合度高，
            对象组合只要求被组合的对象具有良好定义的接口，耦合度低
        - 观察者模式
            - 建立松耦合的通知依赖关系，可以独立地改变目标与观察者
            - 结合信号槽来讲
            - Demux解复用器，Decoder音频解码器，视频解码器，OpenGL Renderer渲染器，AudioPlayer就是通过观察者模式串联起来，通过抽象出一个数据基类作为通知函数notify的参数，来传递各种音视频数据，如FFmpeg的AVPacket，AVFrame，Audio数据等，通知的数据到达各个模块后，通过队列进行缓存，每个模块各自的线程里从数据队列中取出数据进行相应的处理
        - 适配器模式
            - 用于转化接口
            - 目标接口：客户端期望的接口，适配器：持有原有类实现目标接口，原有类
        - 工厂模式
            - [工厂模式](CPP\Design_Pattern\Factory_Pattern\MainForm2.cpp)，设计模式并不是消灭所有变化，而是把变化赶到一个局部的地方
            - ![工厂模式](CPP\Design_Pattern\Factory_Pattern\Snipaste_2023-07-15_11-26-52.png)
            - 用于创建对象而不需要将具体类暴露给客户端，将对象的创建与使用解耦
            - 是依赖倒置原则的实践，避免客户端（编译）依赖具体类，让客户端绕开new操作，多态new
            - 抽象工厂，抽象产品，具体工厂，具体产品
        - 单例模式
            - 线程非安全版本
            - 线程安全版本，一把大锁治天下，缺点就是读取操作频繁的话，效率很低
            - 双检查锁模式，锁前检查一次，可以避免频繁读取效率低问题，锁后检查一次，避免临界状况出现导致创建两次，但因为内存读写reorder不安全
                - m_instance = new Singleton();
                    - 假定new执行顺序，分配内存，执行构造函数，返回分配内存地址，但由于编译器优化和CPU乱序执行等原因，会导致new执行顺序可能变成分配内存，返回分配内存地址，执行构造函数，这就导致了锁前锁后判断都失去了意义。
            - C++11之后静态局部变量的初始化是线程安全的了，可以使用这个特性实现懒汉式单例模式，然后使用静态成员变量实现饿汉式单例模式
    - 2. 通过这个项目熟悉了Qt中的信号槽机制，多线程机制，事件循环
        - 信号槽机制，多线程，事件循环
            - 观察者模式的一种实现
            - 支持槽函数和信号参数不对等的情况，槽函数参数类型式信号参数子序列时就可以通过编译
            - 槽函数的类型支持广泛，支持类成员函数，lambda表达式，仿函数，普通函数，静态函数
            - 支持断开连接操作
            - 支持对象死亡时自动断开连接
            - 支持异步的编程方式
                - 每一个QObject都有一个自己所属的线程，在执行这个对象相关的函数的时候，会将其打包成一个任务投递到目标线程的消息队列中去，然后每一个线程都有一个事件循环，不断地从消息队列中取出任务执行
    - 3. 通过这个项目尝试了一下集成使用ffmpeg库和OpenGL
        - 熟悉了ffmpeg的使用方法以及ffmpeg中各种资源是如何管理的，FFmpeg中各种资源的生命周期是由ffmpeg库内部自行管理，采用上下文和引用计数的方法，客户程序通过ffmpeg提供的API对资源进行资源深浅拷贝以及上下文的管理
        - 使用OpenGL将yuv420p数据转换成rgb数据，能够编写简单的shader对数据进行并行处理

        
- NJU ICS PA
    - 1. 计算机是个状态机，程序是个状态机
    - 2. 熟悉了汇编语言，能够读懂汇编和写一点简单的汇编，包括riscv架构，x86架构，arm架构
    - 3. 学习了一些二进制工具的使用方法objdump反汇编可执行可链接文件，readelf查看和分析elf文件内容（节表，符号表等），objcopy复制elf文件的代码段，addr2line查询elf文件中的地址得到对应源代码位置
    - 4. 熟悉gdb的使用，设置断点breakpoint，观察点watch point，设置layout，编写gdb启动脚本，连接远端的gdb进行调试等
    - 5. 知道如何配置vscode来调试大型C++程序，使用bear生成compile_commands.json即可，再将compile_commands.json配置C/C++插件中
    - 6. 能够读懂复杂的Makefile，该项目中为了管理多个架构，多个模块，Makefile是较为巧妙和复杂的
    - 7. PA1
        - 实现一个简易调试器，通过realline读取命令，再通过strtok去解析命令，然后调用CPU模拟器nemu提供的接口进行相应的操作，单步执行，打印寄存器等
        - 实现表达式求值，包括词法分析，递归求值，同时实现了一个表达式生成器，主要思路是在程序中生成一个随机表达式放到一个临时C文件里，编译执行得到结果
    - 8. PA2
        - 了解CPU取指，译码，执行，更新PC
        - 读懂riscv指令集手册，并在CPU模拟器nemu实现相应指令的取指，译码和执行，可能大概实现了30多条指令
        - 了解什么是运行时环境，了解了硬件，运行时环境，应用程序间的关系
        - 实现了运行时环境的输入输出的部分模块，知道了是什么是端口I/O，在I/O指令中给出对应端口号，CPU就知道要访问那一个设备寄存器， 
        常见设备端口号由专门的规定，简单但是限制很大，为了兼容性，只能添加不能修改，指令集I/O地址空间有限
        - 内存映射，将物理地址空间中的一部分划分出来给到I/O去使用，访问这部分地址即访问设备
    - 9. PA3
        - 批处理系统
            - 一个后台程序，当一个前台程序执行结束后，后台程序自动加载一个新的前台程序来执行
        - 实现批处理操作系统中对文件上下文的管理，包括自陷操作，保存上下文，恢复上下文等内容
        - 实现加载用户程序，实现系统调用，标准输入输出和堆区管理
        - 实现简易的虚拟文件系统
    - 10. PA4
        - 实现操作系统的上下文切换
            - 进程控制块，内核线程，用户进程等概念
        - 实现了操作系统的虚存管理
            - 实现分页机制和MMU
        - 实现分时多任务（用户程序主动让出）和抢占多任务（定时中断强行切换）

- 操作系统
    - 1. 对于应用程序而言，操作系统就是一系列的对象和API，对象包括文件，进程，线程，锁，信号量等，API即创建，读写，销毁等
    - 2. 多处理器编程：从入门到放弃
        - 放弃原子性：“处理器一次执行一条指令” 的基本假设在今天的计算机系统上不再成立
        - 放弃执行顺序：编译器的优化会与多处理器运行逻辑冲突，[sum.c](C/OS/sum.c)
        - 放弃处理器间的可见性：现代处理器也是一个动态编译器，电路将连续的指令“编译”成更小的uops，
        [store-load.c](C/OS/store-load.c)，当x，y指代的不同的内存的时候，对x，y的内存读写可以交换顺序。